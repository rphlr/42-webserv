#include "../../includes/Server/SimpleServer.hpp"

// /* *********************************** *
// **  Canonical Form ******************* *
// * *********************************** */
// SimpleServer::SimpleServer( int domain, int service, int protocol, int port, u_long interface, int bklg ) {
// 	_socket = new ListeningSocket( domain, service, protocol, port, interface, bklg );
// }

/* *********************************** *
**  Core functionnalities ************ *
* *********************************** */
ListeningSocket * SimpleServer::get_socket() {
	return _socket;
}

// /* *********************************** *
// **  Canonical Form ******************* *
// * *********************************** */
SimpleServer::SimpleServer( Server &server ) {
	int domain = AF_INET;
	int service = SOCK_STREAM;
	int protocol = 0;
	int port = server.getPort();
	u_long interface = inet_addr(server.getHost().c_str());
	// u_long interface = INADDR_ANY;
	std::cout << "interface: " << server.getHost().c_str() << std::endl;
	int bklg = 10;
	_socket = new ListeningSocket( domain, service, protocol, port, interface, bklg );
}
#include "../../includes/Server/TestServer.hpp"

// TestServer::TestServer() : SimpleServer( AF_INET, SOCK_STREAM, 0, 6545, INADDR_ANY, 10 ) {
// 	launch();
// }

TestServer::TestServer(Server &server) : SimpleServer( server ) {
	launch();
}

void TestServer::launch() {
	while (true) {
		std::cout << "Waiting for a connection...\n";
		accepter();
		handler();
		responder();
		std::cout << "Done\n";
	}
}

void TestServer::accepter() {
	std::cout << "Accepting...\n";
	memset(_buffer, 0, 300 );
	struct sockaddr_in address = get_socket()->get_address();
	int addrlen = sizeof(address);
	_new_socket = accept(get_socket()->get_sock(), (struct sockaddr *)&address, (socklen_t*)&addrlen);
	read( _new_socket, _buffer, 300 );
}

void TestServer::handler() {
	std::cout << "Handling...\n";
	std::cout << _buffer << std::endl;
}

void TestServer::responder() {
	std::cout << "Responding...\n";
	char *hello = "Hello from server";
	write(_new_socket, hello, strlen(hello));
	close(_new_socket);
}#include "../../includes/Networking/BindingSocket.hpp"

/* *********************************** *
**  Canonical Form ******************* *
* *********************************** */
BindingSocket::BindingSocket( int domain, int service, int protocol, int port, u_long interface ) :
	SimpleSocket( domain, service, protocol, port, interface ) {
	// std::cout << "BindingSocket constructor called\n";
	set_connection(connect_to_network(get_sock(), get_address()));
}

/* *********************************** *
**  Core functionnalities ************ *
* *********************************** */
int BindingSocket::connect_to_network(int sock, struct sockaddr_in address) {
	return bind(sock, (struct sockaddr *)&address, sizeof(address));
}#include "../../includes/Networking/ConnectingSocket.hpp"

/* *********************************** *
**  Canonical Form ******************* *
* *********************************** */
ConnectingSocket::ConnectingSocket( int domain, int service, int protocol, int port, u_long interface ) :
	SimpleSocket( domain, service, protocol, port, interface ) {
	std::cout << "ConnectingSocket constructor called\n";
	set_connection(connect_to_network(get_sock(), get_address()));

}

/* *********************************** *
**  Core functionnalities ************ *
* *********************************** */
int ConnectingSocket::connect_to_network(int sock, struct sockaddr_in address) {
	return bind(sock, (struct sockaddr *)&address, sizeof(address));
}

#include "../../includes/Networking/ListeningSocket.hpp"

// /* *********************************** *
// **  Canonical Form ******************* *
// * *********************************** */
ListeningSocket::ListeningSocket( int domain, int service, int protocol, int port, u_long interface, int bklg ) :
	BindingSocket( domain, service, protocol, port, interface ) {
	// std::cout << "ListeningSocket constructor called\n";
	start_listening();
}

/* *********************************** *
**  Core functionnalities ************ *
* *********************************** */
void ListeningSocket::start_listening() {
	_listening = listen(get_sock(), _backlog);
}
#include "../../includes/Networking/SimpleSocket.hpp"


/* *********************************** *
**  Canonical Form ******************* *
* *********************************** */
SimpleSocket::SimpleSocket( int domain, int service, int protocol, int port, u_long interface) {
	// std::cout << "SimpleSocket constructor called\n";
	_sock = socket(domain, service, protocol);
	_address.sin_family = domain;
	_address.sin_port = htons(port);
	_address.sin_addr.s_addr = htonl(interface);
	// Establish socket
	_sock = socket(domain, service, protocol);
	test_connection(_sock);
}

/* *********************************** *
**  Core functionnalities ************ *
* *********************************** */
void SimpleSocket::test_connection(int to_test) {
	if (to_test < 0) {
		std::cerr << "Error: " << strerror(errno) << std::endl;
		exit(1);
	}
	else {
		// std::cout << "Connection established\n";
	}
}


/* *********************************** *
**  Getters ************************** *
* *********************************** */
int SimpleSocket::get_sock() {
	return _sock;
}

struct sockaddr_in SimpleSocket::get_address() {
	return _address;
}


/* *********************************** *
**  Setters ************************** *
* *********************************** */
void SimpleSocket::set_connection(int con) {
	_connection = con;
}/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   LocationConfig.cpp                                 :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: nvaubien <nvaubien@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/02/21 22:34:00 by ckarl             #+#    #+#             */
/*   Updated: 2024/03/20 12:52:29 by nvaubien         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../includes/Config/LocationConfig.hpp"

Location::Location(void) : _path(""), _redirect(""), _directory_listing(false) {}

Location::~Location(void) {}

Location::Location(const Location &c) : _path(c._path), _redirect(c._redirect),
									 _methods(c._methods), _directory_listing(c._directory_listing) {}

Location &Location::operator = (const Location &c)
{
	if (this != &c) {
		_path = c._path;
		_redirect = c._redirect;
		_directory_listing = c._directory_listing;
		_methods = c._methods;
	}
	return *this;
}

void	Location::setPath(string &p)
{
	if (_path.empty() && !p.empty())
		_path = p;
	else
		throw std::invalid_argument(INVALID_CONF + "location path (empty or double)");
}

void	Location::setRedirect(string &r)
{
	if (_redirect.empty() && !r.empty())
		_redirect = r;
	else
		throw std::invalid_argument(INVALID_CONF + "location redirect (empty or double)");
}

bool	Location::validMethod(string &m)
{
	if (m == "POST" || m == "GET" || m == "HEAD" || m == "CONNECT" || m == "PUT" || m == "DELETE" \
	|| m == "OPTIONS" || m == "TRACE" || m == "PATCH")
		return true;
	return false;
}

void	Location::setMethods(string &m)
{
	//separate string m by ',' to get the diff methods
	//check if valid and not yet set and insert in map
	size_t	pos = 0;
	string	temp;
	while (!m.empty())
	{
		pos = m.find(",");
		if (pos == string::npos)
			temp = m;
		else
			temp = m.substr(0, pos);
		if (std::find(_methods.begin(), _methods.end(), temp)!= _methods.end() || validMethod(temp) == false)
			throw std::invalid_argument(INVALID_CONF + "location method (invalid or double)");
		_methods.push_back(temp);
		if (pos != string::npos)
			m = m.substr(pos + 1);
		else
			m.clear();
	}
}

void	Location::setDirList(string &d)		//check for double listing?
{
	if (!d.empty()) {
		if (d == "on")
			_directory_listing = true;
		else if (d == "off")
			_directory_listing = false;
		else
			throw std::invalid_argument(INVALID_CONF + "location directory_listing (invalid)");
	}
	else
		throw std::invalid_argument(INVALID_CONF + "location directory_listing (empty)");
}

string	&Location::getPath(void) { return _path; }
string	&Location::getRedirect(void) { return _redirect; }
std::vector<string>	&Location::getMethods(void) { return _methods; }
bool	&Location::getDirList(void) { return _directory_listing; }


std::ostream& operator << (std::ostream& os, Location &obj)
{
	if (!obj.getPath().empty())
		std::cout << "path: " << obj.getPath() << std::endl;
	if (!obj.getRedirect().empty())
		std::cout << "redirect: " << obj.getRedirect() << std::endl;
	if (!obj.getMethods().empty()) {
		std::vector<string>	tempMethods = obj.getMethods();
		std::cout << "methods: ";
		for(unsigned int i = 0; i < tempMethods.size(); i++) {
			std::cout << tempMethods[i];
			if (i != tempMethods.size() - 1)
				std::cout << ",";
		}
		std::cout << std::endl;
	}
	std::cout << "directory_listing: " << (obj.getDirList() ? "on" : "off") << std::endl;
	return os;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ParserConfig.cpp                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: nvaubien <nvaubien@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/02/19 18:09:07 by ckarl             #+#    #+#             */
/*   Updated: 2024/03/20 15:03:02 by nvaubien         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../includes/Config/ParserConfig.hpp"

Parser::Parser(void) : inServ(false), inLoc(false), inErr(false), currentServer(NULL) {}

Parser::~Parser(void) { servers.clear(); }

Parser::Parser(const Parser &c) { (void) c; }

Parser &Parser::operator = (const Parser &c)
{
	(void) c;
	return *this;
}

void	Parser::handleLine(string &line)
{
	string	key;
	string	value;
	int		pos;

	//separate by ':' into two parts
	// std::cout << "currentServer in handleLine: " << *currentServer << std::endl;
	// std::cout << "server[0] in handleLine: " << servers[0] << std::endl;

	line = line.substr(0, line.find("#"));
	pos = line.find(sign::DOUBLE_DOT);
	if (pos == (int)std::string::npos)
		throw std::runtime_error(INVALID_CONF + "a line is missing the delimitor ':'");
	key = line.substr(0, pos);
	value = line.substr(pos + 1);
	//send to set function - set in *currentServer
	if (inErr)
		currentServer->setErrorPage(key, value);
	else if (inLoc)
		currentServer->handleLocation(key, value);
	else
		handleSetting(key, value);
}

void	Parser::handleSetting(string &key, string &value)
{
	string	setting[6] = {"server_name", "port", "host", "max_body_size", "root", "default_file"};
	void (Server::*setValue[6])(string &value) = {&Server::setName, &Server::setPort, \
			&Server::setHost, &Server::setSize, &Server::setRoot, &Server::setDefFile};

	for (int i = 0; i < 6; i++) {
		if (key == setting[i]) {
			(currentServer->*setValue[i])(value);
			return ;
		}
	}
	throw std::invalid_argument(INVALID_CONF + "unknown element in settings");

}

vector<Server>	Parser::parseFile(string doc)
{
	std::ifstream	inputFile;

	//check if file can be opened or is empty
	inputFile.open(doc, std::fstream::in);
	if (inputFile.fail() || inputFile.peek() == EOF)
		throw std::runtime_error(FILE_OPENING);

	string line;
	while (std::getline(inputFile, line))
	{
		line.erase(std::remove_if(line.begin(), line.end(), ::isspace), line.end());
		if (line.empty() || line.at(0) == '#')
			continue;
		if (line == "server:") {
			inLoc = false; inErr = false; inServ = true;
			servers.push_back(Server());
			currentServer = &servers.back();//point to next Server
			continue;
		}
		if (line == "error_page:") {
			if (inErr || inLoc || !inServ)
				throw std::runtime_error(SECTION_ERR + "error_page in wrong section");
			inErr = true;
			continue;
		}
		if (line == "location:") {
			if (inServ) {
				inLoc = true; inErr = false;
				currentServer->addLocationChangePointer(); //point to next location inside of same server
			}
			else
				throw std::runtime_error(SECTION_ERR + "location outside of server section");
			continue;
		}
		handleLine(line);
	}
	//print out all servers in the vector
	for(unsigned int i = 0; i < servers.size(); i++) {
		std::cout << "server:" << servers[i] << std::endl;
	}

	//testing if servers are the same or different by comparing name, port and host
	// if (servers[0] == servers[1])
	// 	std::cout << "they're the same" << std::endl;
	// else
	// 	std::cout << "they're different" << std::endl;

	inputFile.close();
	return servers;
}

Server *Parser::getNthServer(int n)
{
	if (n < 0 || n >= (int)servers.size())
		throw std::out_of_range(INVALID_CONF + "server index out of range");
	return &servers[n];
}

/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   ServerConfig.cpp                                   :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: nvaubien <nvaubien@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/02/20 22:40:45 by ckarl             #+#    #+#             */
/*   Updated: 2024/03/20 12:35:24 by nvaubien         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../../includes/Config/ServerConfig.hpp"

Server::Server(void): _server_name(""), _port(-1), _host(""), _max_body_size(-1),
					_root(""), _default_file(""), _currentLoc(nullptr) {}

Server::~Server(void) { _locations.clear(); }

Server::Server(const Server &c) : _server_name(c._server_name), _port(c._port),
								_host(c._host), _max_body_size(c._max_body_size),
								_root(c._root), _default_file(c._default_file),
								_error_pages(c._error_pages), _locations(c._locations),
								_currentLoc(c._currentLoc) {}

Server &Server::operator = (const Server &c)
{
	if (this != &c) {
		_server_name = c._server_name; _port = c._port; _host = c._host;
		_max_body_size = c._max_body_size; _root = c._root; _default_file = c._default_file;
		_error_pages = c._error_pages; _currentLoc = c._currentLoc; _locations = c._locations;
	}
	return *this;
}

void	Server::setName(string &n)
{
	if (n.size() < 20 && !n.empty() && _server_name.empty())
		_server_name = n;
	else
		throw std::invalid_argument(INVALID_CONF + "server_name (too long, empty or double)");
}

void	Server::setPort(string &po)
{
	int p = std::stoi(po);
	if (p > 0 && p < 65535 && _port < 0)
		_port = p;
	else
		throw std::invalid_argument(INVALID_CONF + "port (empty, double or size)");
}

void	Server::setSize(string &si)
{
	int s = std::stoi(si);
	if (s < 1000 && s >= 0 && _max_body_size < 0)					//check for BUFFER_SIZE (maybe throw error?)
		_max_body_size = s;
	else
		throw std::invalid_argument(INVALID_CONF + "max_body_size (empty, double or size)");
}

void	Server::setRoot(string &r)
{
	if (_root.empty() && !r.empty())
		_root = r;
	else
		throw std::invalid_argument(INVALID_CONF + "root (empty or double)");
	//check here if path exists or not?
}

void	Server::setErrorPage(string &c, string &path)
{
	int code = stoi(c);
	if (code >= 100 && code < 600 && _error_pages.find(code) == _error_pages.end())
		_error_pages[code] = path;
	else
		throw std::invalid_argument(INVALID_CONF + "error_page (empty, invalid or double)");
}

void	Server::setHost(string &h)
{
	if (_host.empty() && !h.empty())
		_host = h;
	else
		throw std::invalid_argument(INVALID_CONF + "host (empty or double)");

}

void	Server::setDefFile(string &d)
{
	if (_default_file.empty() && !d.empty())
		_default_file = d;
	else
		throw std::runtime_error(INVALID_CONF + "default_file (empty or double)");
}

string	&Server::getName(void) { return _server_name; }
int		&Server::getPort(void) { return _port; }
string	&Server::getHost(void) { return _host; }
int		&Server::getSize(void) { return _max_body_size; }
string	&Server::getRoot(void) { return _root; }
string	&Server::getDefFile(void) { return _default_file; }
Location	*Server::getCurrentLoc(void) { return _currentLoc; }
string	&Server::getErrorPath(int code)
{
	if (_error_pages.find(code) != _error_pages.end())
		return _error_pages.at(code);
	throw std::logic_error(ERROR_CODE);
}

std::map<int, string>	&Server::getErrorPages(void)
{
	if (!_error_pages.empty())
		return _error_pages;
	throw std::runtime_error(NO_ERR);
}

vector<Location>	&Server::getLocations(void)
{
	if (!_locations.empty())
		return _locations;
	throw std::runtime_error(NO_LOC);
}

bool	Server::isComplete(void)
{
	if (_server_name.empty() || _port < 0 || _host.empty() || _max_body_size < 0 \
		|| _root.empty() || _default_file.empty() || _error_pages.empty() \
		|| _locations.empty())
		return false;
	else
		return true;
}

void	Server::addLocationChangePointer(void)
{
	// std::cout << "server name: " << _server_name << std::endl;
	_locations.push_back(Location());
	_currentLoc = &_locations.back();

}

void	Server::handleLocation(string &key, string &value)
{
	string	locSetting[4] = {"path","redirect", "methods", "directory_listing"};
	void (Location::*setValue[4])(string &value) = {&Location::setPath, &Location::setRedirect, \
			&Location::setMethods, &Location::setDirList};

	for (int i = 0; i < 4; i++) {
		if (key == locSetting[i]) {
			(_currentLoc->*setValue[i])(value);
			return ;
		}
	}
	throw std::invalid_argument(INVALID_CONF + "unknown element in location section");
}

//== overloaded operator (check if name, port or host are the same)
bool	Server::operator == ( const Server &comp )
{
	bool	nameSame = _server_name == comp._server_name;
	bool	portSame = _port == comp._port;
	bool	hostSame = _host == comp._host;

	return nameSame && portSame && hostSame;
}

//outstream overload operator (non-member function)
std::ostream& operator << (std::ostream& os, Server &obj)
{
	if (!obj.isComplete())
		std::cout << "Server is incomplete" << std::endl;
	else {
		std::cout << "server_name: " << obj.getName() << std::endl;
		std::cout << "port: " << obj.getPort() << std::endl;
		std::cout << "host: " << obj.getHost() << std::endl;
		std::cout << "max_body_size: " << obj.getSize() << std::endl;
		std::cout << "root: " << obj.getRoot() << std::endl;
		std::cout << "default_file: " << obj.getDefFile() << std::endl;
		std::cout << std::endl;
		std::cout << "error_pages: " << std::endl;
		std::map<int, string> errP = obj.getErrorPages();
		for (std::map<int, string>::iterator it = errP.begin(); it != errP.end(); it++) {
			std::cout << it->first << ": " << it->second << std::endl;
		}
		std::cout << std::endl;
		vector<Location> locs = obj.getLocations();
		for(unsigned int i = 0; i < locs.size(); i++) {
			std::cout << "location: " << i << std::endl;
			std::cout << locs[i] << std::endl;
			std::cout << std::endl;
		}
	}
	return os;
}/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main.cpp                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: nvaubien <nvaubien@student.42lausanne.c    +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2024/01/26 14:03:58 by rrouille          #+#    #+#             */
/*   Updated: 2024/03/20 14:49:20 by nvaubien         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "../includes/42webserv.hpp"

int	main(int ac, char **av)
{
	Parser	parsing;

	if (ac != 2) {
		std::cout << "Specify a config file as your program parameter" << std::endl;
		return (-1);
	}
	try {
		parsing.parseFile(av[1]);
	}
	catch (std::exception &e)
	{
		std::cout << "\033[1;31mERROR \033[0m" << e.what() << std::endl;
	}

	/* parsing got the private attributes I need for TestServer */

	TestServer	server(*parsing.getNthServer(0));
	return (0);
}